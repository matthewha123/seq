type BEDRecord(_chrom: str, _chromStart: int, _chromEnd: int, 
                _name: str, _score: int, _strand: str, _thickStart: int,
                 _thickEnd: int, _itemRgb: tuple[int, int, int], _blockCount: int, 
                 _blockSizes: list[int], _blockStarts: list[int], numCols: int):
    @property
    def chrom(self: BEDRecord):
        return self._chrom

    @property
    def chromStart(self: BEDRecord):
        return self._chromStart

    @property
    def chromEnd(self: BEDRecord):
        return self._chromEnd

    @property
    def misc(self: BEDRecord):
        return self._name

    @property
    def score(self: BEDRecord):
        return self._score

    @property
    def strand(self: BEDRecord):
        return self._strand
    
    @property
    def thickStart(self: BEDRecord):
        return self._thickStart

    @property
    def thickEnd(self: BEDRecord):
        return self._thickEnd

    @property
    def itemRgb(self: BEDRecord):
        return self._itemRgb
    
    @property
    def blockCount(self: BEDRecord):
        return self._blockCount

    @property
    def blockSizes(self: BEDRecord):
        return self._blockSizes
    
    @property
    def blockStarts(self: BEDRecord):
        return self._blockStarts

    def numCols(self: BEDRecord):
        return self._numCols

class BEDReader:
    validate: bool
    gzip: bool
    copy: bool
    _file: cobj
    _header: list[str]
    col_names: list[str]
    num_necessary_cols: int # min number of columns for valid bed
    data_start_line: int    # the line in the .bed where data starts (after header) 

    def __init__(self: BEDReader, path: str, validate: bool, gzip: bool, copy: bool):
        self.validate = validate
        self.gzip = gzip
        self.copy = copy
        self._file = gzopen(path, "r").__raw__() if gzip else open(path, "r").__raw__()
        self.init_header(path)
        self.col_names = ["chrom", "chromStart", "chromEnd", "name", "score", "strand", "thickStart", "thickEnd", "itemRgb", "blockCount", "blockSizes", "blockStarts"]
        self.num_necessary_cols = 3
            
    @property
    def file(self: BEDReader):
        assert not self.gzip
        p = __array__[cobj](1)
        p.ptr[0] = self._file
        return ptr[File](p.ptr)[0]

    @property
    def gzfile(self: BEDReader):
        assert self.gzip
        p = __array__[cobj](1)
        p.ptr[0] = self._file
        return ptr[gzFile](p.ptr)[0]

    @property
    def header(self: BEDReader) -> list[str]:
        return self._header

    def init_header(self: BEDReader, path: str):
        h: list[str] = list[str]()
        lnum = 0
        for a in self.file._iter():
            if self.is_line_header(a):
                h_line = copy(a) if self.copy else a
                h.append(h_line)
            else:
                break
            lnum += 1
        self._header = h
        self.data_start_line = lnum
        self.close()
        self._file = gzopen(path, "r").__raw__() if self.gzip else open(path, "r").__raw__()

    def is_line_header(self:BEDReader, line: str) -> bool:
        # a line is a header if it starts with #, browser or track

        if line[0] == "#":
            return True
        
        first_word: str = line.split(" ")[0]
        if first_word == "browser" or first_word == "track":
            return True
        
        return False

    def _iter_core(self: BEDReader, file) -> BEDRecord:

        # iterate past header
        for i, _ in enumerate(file._iter()):
            if i == self.data_start_line - 1:
                break

        for lnum, a in enumerate(file._iter()):
            line = copy(a) if self.copy else a
            rec: BEDRecord = self.BEDRecord_from_str(line, lnum)
            yield rec
            
    
    def __iter__(self: BEDReader) -> BEDRecord:
        if self.gzip:
            yield from self._iter_core(self.gzfile)
        else:
            yield from self._iter_core(self.file)

    def BEDRecord_from_str(self: BEDReader, s: str, lnum: int) -> BEDRecord:
        col_vals: list[str] = s.split()

        if len(col_vals) < self.num_necessary_cols:
            raise ValueError(f"Each line in BED file must have at least 3 columns, line: {lnum}")

        misc: dict[str, str] = dict[str, str]()
        chrom = col_vals[0]
        chromStart = 0
        chromEnd = 0
        name: str = ""
        score: int = 0
        strand: str = ""
        thickStart: int = 0
        thickEnd: int = 0
        itemRgb: tuple[int, int, int] = (0,0,0)
        blockCount: int = 0
        blockSizes: list[int] = list[int]()
        blockStarts: list[int] = list[int]()

        lnum = 0

        val_ptrs: list[ptr[byte]] = [ptr[byte](__ptr__(chrom)), ptr[byte](__ptr__(chromStart)),
                                    ptr[byte](__ptr__(chromEnd)), ptr[byte](__ptr__(name)),
                                    ptr[byte](__ptr__(score)), ptr[byte](__ptr__(strand)),
                                    ptr[byte](__ptr__(thickStart)), ptr[byte](__ptr__(thickEnd)),
                                    ptr[byte](__ptr__(itemRgb)), ptr[byte](__ptr__(blockCount)),
                                    ptr[byte](__ptr__(blockSizes)), ptr[byte](__ptr__(blockStarts))]

        for i in range(len(col_vals)):
            col_name = self.col_names[i]
            val = col_vals[i]
            val_ptr = val_ptrs[i]
            match col_name:
                case "chromStart" or "chromEnd" or "score" or "thickStart" or "thickEnd" or "blockCount":
                    val_num_ptr = ptr[int](val_ptr)
                    val_num_ptr[0] = self.get_num_from_bed(val, col_name, lnum)
                case "blockSizes" or "blockStarts":
                    block_val_ptr = ptr[list[int]](val_ptr)
                    block_val_ptr[0] = self.get_block_vals_from_bed(val, blockCount, col_name, lnum)
                case "chrom" or "name":
                    val_str_ptr = ptr[str](val_ptr)
                    val_str_ptr[0] = val
                case "strand":
                    if val == "+" or val == "-":
                        strand = val
                    else:
                        raise ValueError(f"Strand must be + or - was {val}, line {lnum}")
                case "itemRgb":
                    rgb_vals = val.split(",")
                    if len(rgb_vals) != 3:
                        raise ValueError(f"{col_name}, must be 3 comma separated values, line: {lnum}")
                    try:
                        itemRgb = (int(rgb_vals[0]), int(rgb_vals[1]), int(rgb_vals[2]))
                    except:
                        raise ValueError(f"{col_name}, must be integers, line: {lnum}")
                case _:
                    pass
            lnum += 1


        return BEDRecord(chrom, chromStart, chromEnd, name, score, strand,
                         thickStart, thickEnd, itemRgb, blockCount, 
                         blockSizes, blockStarts, len(col_vals))

    def get_num_from_bed(self: BEDReader, val: str, col_name: str, lnum: int) -> int:
        if self.validate:
            try:
                return int(val)
            except:
                raise ValueError(f"{col_name}, must be integer, line: {lnum}")
        return int(val)

    def get_block_vals_from_bed(self: BEDReader, val: str, blockCount: int, col_name: str, lnum: int) -> list[int]:
        # blockCount specifies how many values we should expect in the val str
        # block_vals are a comma separated sequence of integers, found in the val str
        block_vals = val.split(",")
        block_list = list[int]()
        if self.validate and len(block_vals) != blockCount:
            raise ValueError(f"{col_name}, must have the same number of values as blockCount specifies {blockCount}, line: {lnum}")
        for v in block_vals:
            if self.validate:
                try:
                    block_list.append(int(v))
                except:
                    raise ValueError(f"{col_name}, must be a comma separated list of integer values, line: {lnum}")
            else:
                block_list.append(int(v))
        return block_list

    def close(self: BEDReader):
        if self.gzip:
            self.gzfile.close()
        else:
            self.file.close()

def BED(path: str, validate: bool = True, gzip: bool = True, copy: bool = True) -> BEDReader:
    return BEDReader(path=path, validate=validate, gzip=gzip, copy=copy)
