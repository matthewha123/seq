type FAIRecord(_name: str, _length: int, _offset: int, _linebases: int, _linewidth: int, _qualoffset:int):

    @property
    def name(self: FAIRecord):
        return self._name
    
    @property
    def length(self: FAIRecord):
        return self._length

    @property
    def offset(self: FAIRecord):
        return self._offset

    @property
    def linebases(self: FAIRecord):
        return self._linebases

    @property
    def linewidth(self: FAIRecord):
        return self._linewidth
    
    @property
    def qualoffset(self: FAIRecord):
        return self._qualoffset

class FAIReader:
    fastq: bool
    validate: bool
    gzip: bool
    copy: bool
    _file: cobj
    col_names: list[str]
    num_necessary_cols: int # min number of columns for valid fai

    def __init__(self: FAIReader, path: str, fastq: bool, validate: bool, gzip: bool, copy: bool):
        self.validate = validate
        self.gzip = gzip
        self.copy = copy
        self._file = gzopen(path, "r").__raw__() if gzip else open(path, "r").__raw__()
        self.col_names = ["name", "length", "offset", "line_bases", "line_width", "qual_offset"]
        self.num_necessary_cols = 6 if fastq else 5
        self.fastq = fastq

    @property
    def file(self: FAIReader):
        assert not self.gzip
        p = __array__[cobj](1)
        p.ptr[0] = self._file
        return ptr[File](p.ptr)[0]

    @property
    def gzfile(self: FAIReader):
        assert self.gzip
        p = __array__[cobj](1)
        p.ptr[0] = self._file
        return ptr[gzFile](p.ptr)[0]

    def _iter_core(self: FAIReader, file):
        for lnum, l in enumerate(file._iter()):
            line = copy(l) if self.copy else l
            rec: FAIRecord = self.FAIRecord_from_str(line, lnum + 1)
            yield rec
    
    def __iter__(self: FAIReader) -> FAIRecord:
        if self.gzip:
            yield from self._iter_core(self.gzfile)
        else:
            yield from self._iter_core(self.file)
        self.close()

    def FAIRecord_from_str(self: FAIReader, s: str, lnum: int):
        col_strs = s.split("\t")

        if self.validate and len(col_strs) < self.num_necessary_cols:
            raise ValueError(f"Line {lnum} does not have the required number of columns, {self.num_necessary_cols}")

        name, length, offset = "", 0, 0
        line_bases, line_width, qual_offset = 0, 0, 0

        val_ptrs: list[ptr[byte]] = [ptr[byte](__ptr__(name)), ptr[byte](__ptr__(length)), 
                                    ptr[byte](__ptr__(offset)), ptr[byte](__ptr__(line_bases)), 
                                    ptr[byte](__ptr__(line_width)), ptr[byte](__ptr__(qual_offset))]

        for i in range(self.num_necessary_cols):
            col_name = self.col_names[i]
            val_ptr = val_ptrs[i]
            val_str = col_strs[i]
            match col_name:
                case "name":
                    val_str_ptr = ptr[str](val_ptr)
                    val_str_ptr[0] = val_str
                case _:
                    val_num_ptr = ptr[int](val_ptr)
                    val_num_ptr[0] = self.get_int_from_fai(val_str, col_name, lnum)
        
        return FAIRecord(name, length, offset, line_bases, line_width, qual_offset)
    
    def get_int_from_fai(self: FAIReader, val_str: str, col_name: str, lnum: int):
        if self.validate:
            try:
                return int(val_str)
            except:
                raise ValueError(f"{col_name}, must be integer, line: {lnum}")
        return int(val_str)

    def close(self: FAIReader):
        if self.gzip:
            self.gzfile.close()
        else:
            self.file.close()

    def __enter__(self: FAIReader):
        pass

    def __exit__(self: FAIReader):
        self.close()

def FAI(path: str, fastq: bool, validate: bool = True, gzip: bool = True, copy: bool = True) -> FAIReader:
    return FAIReader(path=path, fastq=fastq, validate=validate, gzip=gzip, copy=copy)



