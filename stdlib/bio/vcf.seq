from c_htslib import *

BCF_UN_STR  = 1
BCF_UN_FLT  = 2
BCF_UN_INFO = 4
BCF_UN_SHR  = (BCF_UN_STR|BCF_UN_FLT|BCF_UN_INFO)
BCF_UN_FMT  = 8
BCF_UN_IND  = BCF_UN_FMT
BCF_UN_ALL  = (BCF_UN_SHR|BCF_UN_FMT)

BCF_HL_FLT  =  0
BCF_HL_INFO =  1
BCF_HL_FMT  =  2
BCF_HL_CTG  =  3
BCF_HL_STR  =  4
BCF_HL_GEN  =  5

BCF_HT_FLAG = 0
BCF_HT_INT  = 1
BCF_HT_REAL = 2
BCF_HT_STR  = 3

BCF_VL_FIXED = 0
BCF_VL_VAR   = 1
BCF_VL_A     = 2
BCF_VL_G     = 3
BCF_VL_R     = 4

#define bcf_hdr_id2length(hdr,type,int_id)  ((hdr)->id[BCF_DT_ID][int_id].val->info[type]>>8 & 0xf)
#define bcf_hdr_id2number(hdr,type,int_id)  ((hdr)->id[BCF_DT_ID][int_id].val->info[type]>>12)
#define bcf_hdr_id2type(hdr,type,int_id)    ((hdr)->id[BCF_DT_ID][int_id].val->info[type]>>4 & 0xf)
#define bcf_hdr_id2coltype(hdr,type,int_id) ((hdr)->id[BCF_DT_ID][int_id].val->info[type] & 0xf)
#define bcf_hdr_idinfo_exists(hdr,type,int_id)  ((int_id<0 || bcf_hdr_id2coltype(hdr,type,int_id)==0xf) ? 0 : 1)
#define bcf_hdr_id2hrec(hdr,dict_type,col_type,int_id)    ((hdr)->id[(dict_type)==BCF_DT_CTG?BCF_DT_CTG:BCF_DT_ID][int_id].val->hrec[(dict_type)==BCF_DT_CTG?0:(col_type)])

type char_pp = ptr[ptr[byte]]
type char_p  = ptr[byte]

# l and m are size_t, assume i64
type _kstring_t(_l: i64, 
                _m: i64, 
                _s: char_p)

type _bcf_hrec_t(_type: int, 
                _key: char_p, 
                _value: char_p,
                _nkeys: int, 
                _keys: char_pp, 
                _vals: char_pp)

type _bcf_idinfo_t(_info: ptr[u32], 
                   _hrec: ptr[ptr[_bcf_hrec_t]], 
                   _id: int)

type _bcf_idpair_t(_key: char_p, 
                  _val: ptr[_bcf_idinfo_t])

type _bcf_hdr_t(_n: ptr[i32], 
                _id: ptr[ptr[_bcf_idpair_t]], 
                _dict: ptr[ptr[cobj]], 
                _samples: char_pp,
                _hrec: ptr[ptr[_bcf_hrec_t]],
                _nhrec: int,
                _dirty: int,
                _ntransl: int,
                _transl: ptr[int],
                _nsamples_ori: int,
                _keep_samples: ptr[u8],
                _mem: _kstring_t,
                _m: ptr[i32])

type _variant_t (_type: int, _n: int)

type _bcf_fmt_t(_id: int,
                _n: int,
                _size: int,
                _type: int,
                _p: ptr[u8],
                _p_len: u32,
                _p_off_free: u32 # this is a bit field p_off is first 31, p_free is the last bit
                )

type _bcf_info_t(_key: int,
                 _type: int,
                 _len: int,
                 _v1: i32, # union btwn i32 and float
                 _vptr: ptr[u8],
                 _vptr_len: u32,
                 _vptr_off_free: u32 # bit field, vptr_off is first 31, _free is last
                 )

type _bcf_dec_t(_m_fmt: int, _m_info: int, _m_id: int, _m_als: int, _m_allele: int, _m_flt: int
                _n_flt: int,
                _flt: ptr[int],
                _id: char_p,
                _als: char_p,
                _allele: char_pp,
                _info: ptr[_bcf_info_t],
                _fmt: ptr[_bcf_fmt_t],
                _var: ptr[_variant_t],
                _n_var: int,
                _var_type: int,
                _shared_dirty: int,
                _indiv_dirty: int)

type _bcf1_t(_rid: i32, 
            _pos: i32, 
            _rlen: i32, 
            _qual: float,
            _n_info_allele: u32, # bit field first 16 is info, last 16 is n_allele
            _n_fmt_sample: u32, # first 8 is fmt, last 24 is sample
            _shared: _kstring_t, 
            _indiv: _kstring_t, 
            _d: _bcf_dec_t, 
            _max_unpack: int,
            _unpacked: int, 
            _unpack_size: ptr[int], 
            _errcode: int)

class BCFHeader:
    def __init__(self: BCFHeader, bcf_hdr: cobj):
        self.bcf_hdr = bcf_hdr

class BCFHeaderRecord:
    def __init__(self: BCFHeaderRecord, bcf_hrec: cobj):
        self.bcf_hrec = bcf_hrec
        pass

class BCFRecordFilter:
    # filter status (PASS)
    # or list of filters that fail
    pass

class BCFRecordFormat:
    # mapping from format keys : samples
    pass

class BCFRecordInfo:
    # mapping from info keys: values
    pass

class BCFRecord:
    bcf1: cobj
    header: cobj
    def __init__(self: BCFRecord, bcf1: _bcf1_t, header: BCFHeaderRecord):
        self.bcf1 = bcf1
        self.header = header
    
def bcf_get_value_count(rec: BCFRecord, h1_type: int, id: int, count: ptr[int], scalar: ptr[int], sample: int):
    if record is None:
        raise ValueError('record must not be None')
    
    hdr = rec.header.bcf_hdr
    r   = rec.bcf1
    if 
    

class BCF:
    file: cobj
    hdr: cobj
    seq_hdr: BCFHeader
    bcf1_recs: list[cobj]


    def __init__(self: BCF, path: str):
        path_c_str = path.c_str()
        file = hts_open(path_c_str, "rb".c_str())
        if not file:
            raise IOError("file " + path + " could not be opened")

        self.file = file
        self.hdr = bcf_hdr_read(self.file)
        self.seq_hdr = BCFHeader(self.hdr)
        self.bcf1_recs = list[cobj]()

    def _ensure_open(self: BCF):
        if not self.file:
            raise IOError("I/O operation on closed VCF/BCF file")

    def __iter__(self: BCF):
        self._ensure_open()
        while True:
            bcf1_rec = bcf_init()
            status = int(bcf_read(self.file, self.hdr, bcf1_rec))
            if status == 0:
                bcf_unpack(bcf1_rec, BCF_UN_ALL) # TODO maybe change waht to unpack
                self.bcf1_recs.append(bcf1_rec)
                yield ptr[_bcf1_t](bcf1_rec)[0]
            elif status == -1:
                # end of file
                bcf_destroy(bcf1_rec)
                break
            elif status < -1:
                raise IOError("Critical error while reading BCF file")
            else:
                break

    def close(self: BCF):
        for bcf1_rec in self.bcf1_recs:
            bcf_destroy(bcf1_rec)
        bcf_hdr_destroy(self.hdr)

parser = BCF('./valid_vcf.vcf')
for rec in parser:
    print(rec._pos)
parser.close()



            




