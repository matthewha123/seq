from c_htslib import *

BCF_UN_STR  = 1
BCF_UN_FLT  = 2
BCF_UN_INFO = 4
BCF_UN_SHR  = (BCF_UN_STR|BCF_UN_FLT|BCF_UN_INFO)
BCF_UN_FMT  = 8
BCF_UN_IND  = BCF_UN_FMT
BCF_UN_ALL  = (BCF_UN_SHR|BCF_UN_FMT)

BCF_HL_FLT  =  i32(0)
BCF_HL_INFO =  i32(1)
BCF_HL_FMT  =  i32(2)
BCF_HL_CTG  =  i32(3)
BCF_HL_STR  =  i32(4)
BCF_HL_GEN  =  i32(5)

BCF_HT_FLAG = i32(0)
BCF_HT_INT  = i32(1)
BCF_HT_REAL = i32(2)
BCF_HT_STR  = i32(3)

BCF_VL_FIXED = i32(0)
BCF_VL_VAR   = i32(1)
BCF_VL_A     = i32(2)
BCF_VL_G     = i32(3)
BCF_VL_R     = i32(4)

BCF_DT_ID     =   i32(0)
BCF_DT_CTG    =   i32(1)
BCF_DT_SAMPLE =   i32(2)

BCF_BT_NULL   =  i32(0)
BCF_BT_INT8   =  i32(1)
BCF_BT_INT16  =  i32(2)
BCF_BT_INT32  =  i32(3)
BCF_BT_FLOAT  =  i32(5)
BCF_BT_CHAR   =  i32(7)

BCF_AUX_NONE  = i32(8)

INT8_MIN  = -128
INT16_MIN = -32768
INT32_MIN = -2147483648
bcf_int8_vector_end  = (INT8_MIN+1)
bcf_int16_vector_end = (INT16_MIN+1)
bcf_int32_vector_end = (INT32_MIN+1)
bcf_str_vector_end   = 0
bcf_int8_missing     = INT8_MIN
bcf_int16_missing    = INT16_MIN
bcf_int32_missing    = INT32_MIN
bcf_float_missing    = 0x7F800001
bcf_float_vector_end = 0x7F800002
bcf_str_missing      = 0x07

def ptr_off[T](base: ptr[byte], byte_offset: int) -> ptr[T]:
    return ptr[T](base + byte_offset)

type char_pp = ptr[ptr[byte]]
type char_p  = ptr[byte]

# l and m are size_t, assume i64
type _kstring_t(_l: i64, 
                _m: i64, 
                _s: char_p)

type _bcf_hrec_t(_type: i32, 
                _key: char_p, 
                _value: char_p,
                _nkeys: i32, 
                _keys: char_pp, 
                _vals: char_pp)

type _bcf_idinfo_t(_info0: u32,
                   _info1: u32,
                   _info2: u32,
                   _hrec0 : ptr[_bcf_hrec_t],
                   _hrec1 : ptr[_bcf_hrec_t],
                   _hrec2 : ptr[_bcf_hrec_t], 
                   _id: i32)

type _bcf_idpair_t(_key: char_p, 
                  _val: ptr[_bcf_idinfo_t])

type _bcf_hdr_t(_n0: i32,
                _n1: i32,
                _n2: i32,
                _id0: ptr[_bcf_idpair_t],
                _id1: ptr[_bcf_idpair_t],
                _id2: ptr[_bcf_idpair_t],
                _dict0: ptr[cobj],
                _dict1: ptr[cobj],
                _dict2: ptr[cobj],
                _samples: char_pp,
                _hrec: ptr[ptr[_bcf_hrec_t]],
                _nhrec: i32,
                _dirty: i32,
                _ntransl: i32,
                _transl0: ptr[int],
                _transl1: ptr[int],
                _nsamples_ori: i32,
                _keep_samples: ptr[u8],
                _mem: _kstring_t,
                _m0: i32,
                _m1: i32,
                _m2: i32):
    
    def n(self: _bcf_hdr_t, _type_code: int):
        return ptr_off[i32](ptr[byte](self), _type_code * 4)[0]
    
    def id(self: _bcf_hdr_t, _type_code: int):
        return ptr_off[_bcf_idpair_t](ptr[byte](self), 12 + _type_code * 8)

type _variant_t (_type: i32, _n: i32)

type _bcf_fmt_t(_id: i32,
                _n: i32,
                _size: i32,
                _type: i32,
                _p: ptr[u8],
                _p_len: u32,
                _p_off_free: u32 # this is a bit field p_off is first 31, p_free is the last bit
                )

def _bcf_hdr_int2id(hdr: ptr[_bcf_hdr_t], _type: i32, _int_id: i32):  
    
    _id = hdr[0]._id0
    if _type == i32(1):
        _id = hdr[0]._id1
    elif _type == i32(2):
        _id = hdr[0]._id2
    
    return _id[int(_int_id)]._key

type _bcf_info_t(_key: i32,
                 _type: i32,
                 _len: i32,
                 _v1: i32, # union btwn i32 and float
                 _vptr: ptr[u8],
                 _vptr_len: u32,
                 _vptr_off_free: u32 # bit field, vptr_off is first 31, _free is last
                 ):

    @property
    def v1(self: _bcf_info_t):
        return self._v1

    @property
    def key_code(self: _bcf_info_t):
        return self._key

    def key_str(self: _bcf_info_t, bcf_hdr: ptr[_bcf_hdr_t]):
        key = _bcf_hdr_int2id(bcf_hdr, BCF_DT_ID, self._key)
        return str.from_ptr(key)
    
    def key_code_from_ptr(self: _bcf_info_t):
        return ptr_off[i32](ptr[byte](__ptr__(self)), 0)[0]
    
    def self_ptr(self:_bcf_info_t):
        return __ptr__(self)


type _bcf_dec_t(_m_fmt: i32, _m_info: i32, _m_id: i32, _m_als: i32, _m_allele: i32, _m_flt: i32,
                _n_flt: i32,
                _flt: ptr[i32],
                _id: char_p,
                _als: char_p,
                _allele: char_pp,
                _info: ptr[_bcf_info_t],
                _fmt: ptr[_bcf_fmt_t],
                _var: ptr[_variant_t],
                _n_var: i32,
                _var_type: i32,
                _shared_dirty: i32,
                _indiv_dirty: i32)

type _bcf1_t(_rid: i32, 
            _pos: i32, 
            _rlen: i32, 
            _qual: i32, # Float
            _n_info_allele: u32, # bit field first 16 is info, last 16 is n_allele
            _n_fmt_sample: u32, # first 8 is fmt, last 24 is sample
            _shared: _kstring_t, 
            _indiv: _kstring_t, 
            _d: _bcf_dec_t, 
            _max_unpack: i32,
            _unpacked: i32, 
            _unpack_size_0: i32,
            _unpacK_size_1: i32,
            _unpack_size_2: i32,
            _errcode: i32):

            # TODO make these return ints too
            @property
            def n_info(self: _bcf1_t):
                return self._n_info_allele & u32(0x0000ffff)
            
            @property
            def n_allele(self: _bcf1_t):
                return ((self._n_info_allele & u32(0xffff0000)) >> u32(16))
            
            @property
            def n_sample(self: _bcf1_t):
                return int((self._n_fmt_sample & u32(0xffffff00)) >> u32(8))

            @property
            def n_fmt(self: _bcf1_t):
                return int(self._n_fmt_sample & u32(0x000000ff))

#define bcf_hdr_id2length(hdr,type,int_id)  ((hdr)->id[BCF_DT_ID][int_id].val->info[type]>>8 & 0xf)
#define bcf_hdr_id2number(hdr,type,int_id)  ((hdr)->id[BCF_DT_ID][int_id].val->info[type]>>12)
#define bcf_hdr_id2coltype(hdr,type,int_id) ((hdr)->id[BCF_DT_ID][int_id].val->info[type] & 0xf)
#define bcf_hdr_idinfo_exists(hdr,type,int_id)  ((int_id<0 || bcf_hdr_id2coltype(hdr,type,int_id)==0xf) ? 0 : 1)
#define bcf_hdr_id2hrec(hdr,dict_type,col_type,int_id)    ((hdr)->id[(dict_type)==BCF_DT_CTG?BCF_DT_CTG:BCF_DT_ID][int_id].val->hrec[(dict_type)==BCF_DT_CTG?0:(col_type)])
#define bcf_hdr_int2id(hdr,type,int_id) ((hdr)->id[type][int_id].key)

#define bcf_hdr_id2type(hdr,type,int_id)    ((hdr)->id[BCF_DT_ID][int_id].val->info[type]>>4 & 0xf)
def get_idinfo(idinfo: _bcf_idinfo_t, _type: i32):
    ret = idinfo._info0
    if _type == i32(1):
        ret = idinfo._info1
    elif _type == i32(2):
        ret = idinfo._info2
    return ret

def _bcf_hdr_id2type(hdr: ptr[_bcf_hdr_t], _type: i32, _int_id: i32):
    return (get_idinfo(hdr[0]._id0[int(_int_id)]._val[0], _type) >> u32(4)) & u32(0xf)

def _bcf_hdr_id2length(hdr: ptr[_bcf_hdr_t], _type: i32, _int_id: i32):
    return (get_idinfo(hdr[0]._id0[int(_int_id)]._val[0], _type) >> u32(8)) & u32(0xf)

def _bcf_hdr_id2number(hdr: ptr[_bcf_hdr_t], _type: i32, _int_id: i32):
    return get_idinfo(hdr[0]._id0[int(_int_id)]._val[0], _type) >> u32(12)

def _bcf_hdr_id2coltype(hdr: ptr[_bcf_hdr_t], _type: i32, _int_id: i32):
    return get_idinfo(hdr[0]._id0[int(_int_id)]._val[0], _type) & u32(0xf)

# ((int_id<0 || bcf_hdr_id2coltype(hdr,type,int_id)==0xf) ? 0 : 1)
def _bcf_hdr_idinfo_exists(hdr: ptr[_bcf_hdr_t], _type: i32, _int_id: i32):
    v = _int_id < i32(0) or (_bcf_hdr_id2coltype(hdr, _type, _int_id) == u32(0xf))
    return 0 if v else 1

def check_header_id(hdr: ptr[_bcf_hdr_t], h1_type: i32, id: i32):
    n = hdr[0]._n0
    return id >= i32(0) and id < n and _bcf_hdr_idinfo_exists(hdr, h1_type, id)

def is_gt_fmt(hdr: ptr[_bcf_hdr_t], fmt_id: i32):
    fmt = str.from_ptr(_bcf_hdr_int2id(hdr, BCF_DT_ID, fmt_id))
    return fmt == "GT"


def bcf_float_is_missing(f: i32):
    return 1 if f == i32(bcf_float_missing) else 0

def bcf_float_is_vector_end(f: i32):
    return 1 if f == i32(bcf_float_vector_end) else 0

class BCFHeaderMetaData:
    bcf_hdr: ptr[_bcf_hdr_t]
    _type_code: int

    def __init__(self: BCFHeaderMetaData, bcf_hdr: ptr[_bcf_hdr_t], _type_code: int):
        self.bcf_hdr = bcf_hdr
        self._type_code = _type_code

    @property
    def type_code(self: BCFHeaderMetaData):
        return self._type_code
    
    def __len__(self: BCFHeaderMetaData):
        n = 0
        for i in range(self.bcf_hdr[0].n(int(BCF_DT_ID))):
            pass
    def __iter__(self: BCFHeaderMetaData):
        pass

class BCFHeader:
    bcf_hdr: ptr[_bcf_hdr_t]
    def __init__(self: BCFHeader, bcf_hdr: ptr[_bcf_hdr_t]):
        self.bcf_hdr = bcf_hdr
    
    @property
    def info(self: BCFHeader):
        # get metadata for info fields in Header
        pass

# type_flag is one of BCF_BT_X, or BCF_HT_FLAG or BCF_AUX_NONE
# if array_flag is True, then BCFAux represents an array of type
# specified by type code
type BCFAux(_p: cobj, _type_code: i32, _is_array: bool):

    # accepts as T: i8, i16, i32
    @property
    def val[T](self: BCFAux):
        if self._is_array:
            raise TypeError("This BCFAux represents an array, not a single value")
        return ptr[T](self._p)[0]
    
    @property
    def arr[T](self: BCFAux):
        if not self._is_array:
            raise TypeError("This BCFAux represents a single value, not an array")
        return ptr[list[T]](self._p)[0]
    
    @property
    def type_code(self: BCFAux):
        return self._type_code
    
    @property
    def is_array(self: BCFAux):
        return self._is_array

def bcf_get_value_count(bcf1: ptr[_bcf1_t], bcf_hdr: ptr[_bcf_hdr_t], h1_type: i32, id: i32, sample: i32) -> tuple[i64, i32]:
    if not check_header_id(bcf_hdr, h1_type, id):
        raise ValueError("Invalid header")
    
    length = _bcf_hdr_id2length(bcf_hdr, h1_type, id)
    number = _bcf_hdr_id2number(bcf_hdr, h1_type, id)

    scalar = i32(0)
    count = i64(0)

    if h1_type == BCF_HL_FMT and is_gt_fmt(bcf_hdr, id):
        count = i64(int(number))
    elif i32(length) == BCF_VL_FIXED:
        scalar = i32(1)
    elif i32(length) == BCF_VL_R:
        count = i64(int(bcf1[0].n_allele))
    elif i32(length) == BCF_VL_A:
        count = i64(int(bcf1[0].n_allele - u32(1)))
    # TODO do
    # elif length == BCF_VL_G:
    #     count[0]
    elif i32(length) == BCF_VL_VAR:
        count = i64(-1)
    else:
        raise ValueError('Unknown format length')
    
    return (count, scalar)

def bcf_array_to_object(data: cobj, type_code: i32, n: i32, count: i64, scalar: i32) -> BCFAux:
    def bcf_num_array_to_object[T](data: cobj, type_code: i32, n: i32, vector_end: T, missing_val: T):
        arr = list[T]()
        nums = ptr[T](data)
        for i in range(int(n)):
            if nums[i] == vector_end:
                break
            if nums[i] != missing_val:
                arr.append(nums[i])
        return BCFAux(cobj(__ptr__(arr)), type_code, True)

    
    none_ret = BCFAux(cobj(data), BCF_AUX_NONE, False)
    if not data or n <= i32(0):
        return none_ret
    
    if type_code == BCF_BT_CHAR:
        datac = char_p(data)
        # check null terminator
        b: str = ""
        if datac[int(n)-1] == byte(bcf_str_vector_end):
            b = str.from_ptr(datac)
        else:
            copied_datac = char_p(int(n))
            for i in range(int(n)):
                copied_datac[i] = datac[i]
            b = str.from_ptr(copied_datac)
        arr = list[str]()
        for c in b.split(','):
            if c.c_str()[0] != byte(bcf_str_missing):
                arr.append(c)
        return BCFAux(cobj(__ptr__(arr)), BCF_BT_CHAR, True)
    
    else:
        if type_code == BCF_BT_INT8:
            return bcf_num_array_to_object[i8](data, BCF_BT_INT8, n, i8(bcf_int8_vector_end), i8(bcf_int8_missing))
        elif type_code == BCF_BT_INT16:
            return bcf_num_array_to_object[i16](data, BCF_BT_INT16, n, i16(bcf_int16_vector_end), i16(bcf_int16_missing))
        elif type_code == BCF_BT_INT32:
            return bcf_num_array_to_object[i32](data, BCF_BT_INT32, n, i32(bcf_int32_vector_end), i32(bcf_int32_missing))
        elif type_code == BCF_BT_FLOAT:
            arr = list[i32]()
            nums = ptr[i32](data)
            for i in range(int(n)):
                if bcf_float_is_vector_end(i32(nums[i])):
                    break
                if not bcf_float_is_missing(i32(nums[i])):
                    arr.append(nums[i])
            return BCFAux(cobj(__ptr__(arr)), BCF_BT_FLOAT, True)
        else:
            raise TypeError('unsupported info type code')
    
    return none_ret    

def bcf_info_get_value(bcf1: ptr[_bcf1_t], bcf_hdr: ptr[_bcf_hdr_t], info: ptr[_bcf_info_t]) -> BCFAux:
    count_and_scalar = bcf_get_value_count(bcf1, bcf_hdr, BCF_HL_INFO, info[0]._key, i32(-1))
    count = count_and_scalar[0]
    scalar = count_and_scalar[1]

    i = info[0]
    t = i._type

    none_ret = BCFAux(cobj(bcf1), BCF_AUX_NONE, False)

    if i._len == i32(0):
        if _bcf_hdr_id2type(bcf_hdr, BCF_HL_INFO, i._key) == u32(BCF_HT_FLAG):
            value = True
            # TODO BCF_HT_FLAG is the same as BCF_BT_NULL, this may lead to some confusion
            return BCFAux(cobj(__ptr__(value)), BCF_HT_FLAG, False)
        elif scalar != i32(0):
            # no value
            return none_ret
        else:
            # no value
            return none_ret
    elif i._len == i32(1):
        value = i32(i.v1)
        if i._type == BCF_BT_INT8:
            return BCFAux(cobj(__ptr__(value)), BCF_BT_INT8, False) if i._v1 != i32(bcf_int8_missing) else none_ret
        elif i._type == BCF_BT_INT16:
            return BCFAux(cobj(__ptr__(value)), BCF_BT_INT16, False) if i._v1 != i32(bcf_int16_missing) else none_ret 
        elif i._type == BCF_BT_INT32:
            return BCFAux(cobj(__ptr__(value)), BCF_BT_INT32, False) if i._v1 != i32(bcf_int32_missing) else none_ret
        elif i._type == BCF_BT_FLOAT:
            return BCFAux(cobj(__ptr__(value)), BCF_BT_FLOAT, False) if not bcf_float_is_missing(i._v1) else none_ret
        elif i._type == BCF_BT_CHAR:
            return BCFAux(cobj(__ptr__(value)), BCF_BT_CHAR, False)
        else:
            raise TypeError('unsupported info type code')
    else:
        return bcf_array_to_object(cobj(i._vptr), i._type, i._len, count, scalar)

class BCFRecordInfo:
    # mapping from info keys: values
    bcf1: ptr[_bcf1_t]
    bcf_hdr: ptr[_bcf_hdr_t]
    def __init__(self: BCFRecordInfo, bcf1: ptr[_bcf1_t], bcf_hdr: ptr[_bcf_hdr_t]):
        self.bcf1 = bcf1
        self.bcf_hdr = bcf_hdr
    
    def __iter__(self: BCFRecordInfo):
        hdr = self.bcf_hdr
        r = self.bcf1

        if bcf_unpack(cobj(r), BCF_UN_INFO) < 0:
            raise ValueError('Error unpacking info in BCFRecord')
                
        for i in range(int(r[0].n_info)):
            info = r[0]._d._info[i]
            if info._vptr:
                key = _bcf_hdr_int2id(hdr, BCF_DT_ID, info._key)
                key_s = str.from_ptr(key)
                if key_s != 'END':
                    yield key_s
    
    def __len__(self: BCFRecordInfo):
        count = 0
        for s in self:
            count += 1
        return count

    def __getitem__(self: BCFRecordInfo, key: str):
        hdr = self.bcf_hdr
        r = self.bcf1

        if bcf_unpack(cobj(r), BCF_UN_INFO) < 0:
            raise ValueError('Error unpacking info in BCFRecord')
        if key == "END":
            raise KeyError('END is a reserved key')

        c_key = key.c_str()
        info = ptr[_bcf_info_t](bcf_get_info(cobj(hdr), cobj(r), c_key))

        # TODO need to check for null info and implement bcf_header_get_info
        # see https://github.com/pysam-developers/pysam/blob/master/pysam/libcbcf.pyx#L545
        info_id = info[0]._key
        
        if info_id < i32(0):
            raise KeyError("Unknown info field: " + key)

        if not check_header_id(hdr, BCF_HL_INFO, info_id):
            raise ValueError("Invalid Header")

        # if flag then return whether points are not null
        if _bcf_hdr_id2type(hdr, BCF_HL_INFO, info_id) == u32(BCF_HT_FLAG):
            # TODO return that info and info_id are not null ptrs
            value = info and info[0]._vptr
            return BCFAux(cobj(__ptr__(value)), BCF_HT_FLAG, False)
        
        if not info or not info[0]._vptr:
            raise KeyError('Invalid Info field: ' + key)

        return bcf_info_get_value(r, hdr, info)
    
class BCFRecordSample:
    bcf1: ptr[_bcf1_t]
    bcf_hdr: ptr[_bcf_hdr_t]
    index: int

    def __init__(self: BCFRecordSample, bcf1: ptr[_bcf1_t], bcf_hdr: ptr[_bcf_hdr_t], index: i32):
        self.index = index
        self.bcf1 = bcf1
        self.bcf_hdr = bcf_hdr 

    @property
    def name(self: BCFRecordSample):
        yield str.from_ptr(self.bcf_hdr[0]._samples[self.index])

    # TODO, various operations like getting alleles, allele indices

class BCFRecordSamples:
    bcf1: ptr[_bcf1_t]
    bcf_hdr: ptr[_bcf_hdr_t]
    def __init__(self: BCFRecordSamples, bcf1: ptr[_bcf1_t], bcf_hdr: ptr[_bcf_hdr_t]):
        self.bcf1 = bcf1
        self.bcf_hdr = bcf_hdr
    
    def __len__(self: BCFRecordSamples):
        return self.bcf1[0].n_sample
    
    def __iter__(self: BCFRecordSamples):
        print(len(self), "samples")
        for i in range(int(len(self))):
            yield str.from_ptr(self.bcf_hdr[0]._samples[i])
    
    # TODO, getitem for BCFRecordSample (singular)

class BCFRecordFormat:
    bcf1: ptr[_bcf1_t]
    bcf_hdr: ptr[_bcf_hdr_t]
    def __init__(self: BCFRecordFormat, bcf1: ptr[_bcf1_t], bcf_hdr: ptr[_bcf_hdr_t]):
        self.bcf1 = bcf1
        self.bcf_hdr = bcf_hdr
    
    def __len__(self: BCFRecordFormat):
        return self.bcf1[0].n_fmt
    
    def __iter__(self: BCFRecordFormat):
        if bcf_unpack(cobj(self.bcf1), BCF_UN_FMT) < 0:
            raise ValueError("Error unpacking format")

        for i in range(len(self)):
            fmt = self.bcf1[0]._d._fmt[i]
            if fmt._p:
                yield str.from_ptr(_bcf_hdr_int2id(self.bcf_hdr, BCF_DT_ID, fmt._id))

class BCFRecord:
    bcf1: ptr[_bcf1_t]
    bcf_hdr: ptr[_bcf_hdr_t]
    _info: BCFRecordInfo
    _samples: BCFRecordSamples
    _format: BCFRecordFormat

    def __init__(self: BCFRecord, bcf1: ptr[_bcf1_t], bcf_hdr: ptr[_bcf_hdr_t]):
        self.bcf1 = bcf1
        self.bcf_hdr = bcf_hdr
        self._info = BCFRecordInfo(bcf1, bcf_hdr)
        self._samples = BCFRecordSamples(bcf1, bcf_hdr)
        self._format = BCFRecordFormat(bcf1, bcf_hdr)
    
    @property
    def info(self: BCFRecord):
        return self._info
    
    @property
    def samples(self: BCFRecord):
        return self._samples

    @property
    def format(self: BCFRecord):
        return self._format

    @property
    def n_info(self: BCFRecord):
        return self.bcf1[0].n_info

    def __str__(self: BCFRecord):
        return "[BCFRecord: rid: " + str(self.bcf1[0]._rid) + ", pos: " + str(self.bcf1[0]._pos) + ", rlen: " + str(self.bcf1[0]._rlen) + ", n_info: " + str(self.n_info) + " ]"

class BCF:
    file: cobj
    hdr: cobj
    seq_hdr: BCFHeader
    bcf1_recs: list[cobj]

    def __init__(self: BCF, path: str):
        path_c_str = path.c_str()
        file = hts_open(path_c_str, "rb".c_str())
        if not file:
            raise IOError("file " + path + " could not be opened")

        self.file = file
        self.hdr = bcf_hdr_read(self.file)
        self.seq_hdr = BCFHeader(ptr[_bcf_hdr_t](self.hdr))
        self.bcf1_recs = list[cobj]()

    def _ensure_open(self: BCF):
        if not self.file:
            raise IOError("I/O operation on closed VCF/BCF file")

    def __iter__(self: BCF):
        self._ensure_open()
        while True:
            bcf1_rec = bcf_init()
            status = int(bcf_read(self.file, self.hdr, bcf1_rec))
            if status == 0:
                unpack_status = int(bcf_unpack(bcf1_rec, BCF_UN_FLT)) # TODO maybe change waht to unpack
                self.bcf1_recs.append(bcf1_rec)
                yield BCFRecord(ptr[_bcf1_t](bcf1_rec), ptr[_bcf_hdr_t](self.hdr))
            
            elif status == -1:
                # end of file
                bcf_destroy(bcf1_rec)
                break
            elif status < -1:
                raise IOError("Critical error while reading BCF file")
            else:
                break

    def close(self: BCF):
        for bcf1_rec in self.bcf1_recs:
            bcf_destroy(bcf1_rec)
        bcf_hdr_destroy(self.hdr)

parser = BCF('./valid_vcf.vcf')
for rec in parser:
    print(rec)
    for k in rec.info:
        aux = rec.info[k]
        type_code = aux.type_code
        is_array = aux._is_array
        if type_code == BCF_BT_INT8 :
            if is_array:
                print("key", k, "val", aux.arr[i8], "type_code", type_code)
            else:
                print("key", k, "val", aux.val[i8], "type_code", type_code)
        elif type_code == BCF_BT_INT16:
            if is_array:
                print("key", k, "val", aux.arr[i16], "type_code", type_code)
            else:
                print("key", k, "val", aux.val[i16], "type_code", type_code)
        elif type_code == BCF_BT_INT32:
            if is_array:
                print("key", k, "val", aux.arr[i32], "type_code", type_code)
            else:
                print("key", k, "val", aux.val[i32], "type_code", type_code)
        elif type_code == BCF_BT_FLOAT:
            if is_array:
                print("key", k, "val", aux.arr[i32], "type_code", type_code)
            else:
                print("key", k, "val", aux.val[i32], "type_code", type_code)
        elif type_code == BCF_BT_CHAR :
            if is_array:
                print("key", k, "val", aux.arr[byte], "type_code", type_code)
            else:
                print("key", k, "val", aux.val[byte], "type_code", type_code)
        elif type_code == BCF_HT_FLAG :
            if is_array:
                print("key", k, "val", aux.arr[bool], "type_code", type_code)
            else:
                print("key", k, "val", aux.val[bool], "type_code", type_code)
    for samp in rec.samples:
        print("sample", samp)
    for fm in rec.format:
        print("format", fm)
parser.close()



            




