from c_htslib import *

BCF_UN_STR  = 1
BCF_UN_FLT  = 2
BCF_UN_INFO = 4
BCF_UN_SHR  = (BCF_UN_STR|BCF_UN_FLT|BCF_UN_INFO)
BCF_UN_FMT  = 8
BCF_UN_IND  = BCF_UN_FMT
BCF_UN_ALL  = (BCF_UN_SHR|BCF_UN_FMT)

BCF_HL_FLT  =  i32(0)
BCF_HL_INFO =  i32(1)
BCF_HL_FMT  =  i32(2)
BCF_HL_CTG  =  i32(3)
BCF_HL_STR  =  i32(4)
BCF_HL_GEN  =  i32(5)

BCF_HT_FLAG = i32(0)
BCF_HT_INT  = i32(1)
BCF_HT_REAL = i32(2)
BCF_HT_STR  = i32(3)

BCF_VL_FIXED = i32(0)
BCF_VL_VAR   = i32(1)
BCF_VL_A     = i32(2)
BCF_VL_G     = i32(3)
BCF_VL_R     = i32(4)

BCF_DT_ID     =   i32(0)
BCF_DT_CTG    =   i32(1)
BCF_DT_SAMPLE =   i32(2)

BCF_BT_NULL   =  i32(0)
BCF_BT_INT8   =  i32(1)
BCF_BT_INT16  =  i32(2)
BCF_BT_INT32  =  i32(3)
BCF_BT_FLOAT  =  i32(5)
BCF_BT_CHAR   =  i32(7)

BCF_AUX_NONE  = i32(8)

INT8_MIN  = -128
INT16_MIN = -32768
INT32_MIN = -2147483648
bcf_int8_vector_end  = (INT8_MIN+1)
bcf_int16_vector_end = (INT16_MIN+1)
bcf_int32_vector_end = (INT32_MIN+1)
bcf_str_vector_end   = 0
bcf_int8_missing     = INT8_MIN
bcf_int16_missing    = INT16_MIN
bcf_int32_missing    = INT32_MIN
bcf_float_missing    = 0x7F800001
bcf_float_vector_end = 0x7F800002
bcf_str_missing      = 0x07

def ptr_off[T](base: ptr[byte], byte_offset: int) -> ptr[T]:
    return ptr[T](base + byte_offset)

type char_pp = ptr[ptr[byte]]
type char_p  = ptr[byte]

# l and m are size_t, assume i64
type _kstring_t(_l: i64, 
                _m: i64, 
                _s: char_p)

type _bcf_hrec_t(_type: i32, 
                _key: char_p, 
                _value: char_p,
                _nkeys: i32, 
                _keys: char_pp, 
                _vals: char_pp)

type _bcf_idinfo_t(_info0: u32,
                   _info1: u32,
                   _info2: u32,
                   _hrec0 : ptr[_bcf_hrec_t],
                   _hrec1 : ptr[_bcf_hrec_t],
                   _hrec2 : ptr[_bcf_hrec_t], 
                   _id: i32):
                   
    def info(self: _bcf_idinfo_t, _type: int):
        info = self._info0
        if _type == 1:
            info = self._info1
        elif _type == 2:
            info = self._info2
        return info

type _bcf_idpair_t(_key: char_p, 
                  _val: ptr[_bcf_idinfo_t])

type _bcf_hdr_t(_n0: i32,
                _n1: i32,
                _n2: i32,
                _id0: ptr[_bcf_idpair_t],
                _id1: ptr[_bcf_idpair_t],
                _id2: ptr[_bcf_idpair_t],
                _dict0: ptr[cobj],
                _dict1: ptr[cobj],
                _dict2: ptr[cobj],
                _samples: char_pp,
                _hrec: ptr[ptr[_bcf_hrec_t]],
                _nhrec: i32,
                _dirty: i32,
                _ntransl: i32,
                _transl0: ptr[int],
                _transl1: ptr[int],
                _nsamples_ori: i32,
                _keep_samples: ptr[u8],
                _mem: _kstring_t,
                _m0: i32,
                _m1: i32,
                _m2: i32):
    
    def n(self: _bcf_hdr_t, _type_code: int):
        n = self._n0
        if _type_code == 1:
            n = self._n1
        elif _type_code == 2:
            n = self._n2
        return n
    
    def id(self: _bcf_hdr_t, _type_code: int):
        _id = self._id0
        if _type_code == 1:
            _id = self._id1
        elif _type_code == 2:
            _id = self._id2
        return _id
    
    def _dict(self: _bcf_hdr_t, _type_code):
        _dict = self._dict0
        if _type_code == 1:
            _dict = self._dict1
        elif _type_code == 2:
            _dict = self._dict2
        return _dict

type _variant_t (_type: i32, _n: i32)

type _bcf_fmt_t(_id: i32,
                _n: i32,
                _size: i32,
                _type: i32,
                _p: ptr[u8],
                _p_len: u32,
                _p_off_free: u32 # this is a bit field p_off is first 31, p_free is the last bit
                )

def _bcf_hdr_int2id(hdr: ptr[_bcf_hdr_t], _type: i32, _int_id: i32):  
    return hdr[0].id(int(_type))[int(_int_id)]._key

type _bcf_info_t(_key: i32,
                 _type: i32,
                 _len: i32,
                 _v1: i32, # union btwn i32 and float
                 _vptr: ptr[u8],
                 _vptr_len: u32,
                 _vptr_off_free: u32 # bit field, vptr_off is first 31, _free is last
                 ):

    @property
    def v1(self: _bcf_info_t):
        return self._v1

    @property
    def key_code(self: _bcf_info_t):
        return self._key

    def key_str(self: _bcf_info_t, bcf_hdr: ptr[_bcf_hdr_t]):
        key = _bcf_hdr_int2id(bcf_hdr, BCF_DT_ID, self._key)
        return str.from_ptr(key)
    
    def key_code_from_ptr(self: _bcf_info_t):
        return ptr_off[i32](ptr[byte](__ptr__(self)), 0)[0]
    
    def self_ptr(self:_bcf_info_t):
        return __ptr__(self)


type _bcf_dec_t(_m_fmt: i32, _m_info: i32, _m_id: i32, _m_als: i32, _m_allele: i32, _m_flt: i32,
                _n_flt: i32,
                _flt: ptr[i32],
                _id: char_p,
                _als: char_p,
                _allele: char_pp,
                _info: ptr[_bcf_info_t],
                _fmt: ptr[_bcf_fmt_t],
                _var: ptr[_variant_t],
                _n_var: i32,
                _var_type: i32,
                _shared_dirty: i32,
                _indiv_dirty: i32)

type _bcf1_t(_rid: i32, 
            _pos: i32, 
            _rlen: i32, 
            _qual: i32, # Float
            _n_info_allele: u32, # bit field first 16 is info, last 16 is n_allele
            _n_fmt_sample: u32, # first 8 is fmt, last 24 is sample
            _shared: _kstring_t, 
            _indiv: _kstring_t, 
            _d: _bcf_dec_t, 
            _max_unpack: i32,
            _unpacked: i32, 
            _unpack_size_0: i32,
            _unpacK_size_1: i32,
            _unpack_size_2: i32,
            _errcode: i32):

            # TODO make these return ints too
            @property
            def n_info(self: _bcf1_t):
                return self._n_info_allele & u32(0x0000ffff)
            
            @property
            def n_allele(self: _bcf1_t):
                return ((self._n_info_allele & u32(0xffff0000)) >> u32(16))
            
            @property
            def n_sample(self: _bcf1_t):
                return int((self._n_fmt_sample & u32(0xffffff00)) >> u32(8))

            @property
            def n_fmt(self: _bcf1_t):
                return int(self._n_fmt_sample & u32(0x000000ff))

#define bcf_hdr_id2length(hdr,type,int_id)  ((hdr)->id[BCF_DT_ID][int_id].val->info[type]>>8 & 0xf)
#define bcf_hdr_id2number(hdr,type,int_id)  ((hdr)->id[BCF_DT_ID][int_id].val->info[type]>>12)
#define bcf_hdr_id2coltype(hdr,type,int_id) ((hdr)->id[BCF_DT_ID][int_id].val->info[type] & 0xf)
#define bcf_hdr_idinfo_exists(hdr,type,int_id)  ((int_id<0 || bcf_hdr_id2coltype(hdr,type,int_id)==0xf) ? 0 : 1)
#define bcf_hdr_id2hrec(hdr,dict_type,col_type,int_id)    ((hdr)->id[(dict_type)==BCF_DT_CTG?BCF_DT_CTG:BCF_DT_ID][int_id].val->hrec[(dict_type)==BCF_DT_CTG?0:(col_type)])
#define bcf_hdr_int2id(hdr,type,int_id) ((hdr)->id[type][int_id].key)

#define bcf_hdr_id2type(hdr,type,int_id)    ((hdr)->id[BCF_DT_ID][int_id].val->info[type]>>4 & 0xf)
# static inline const char *bcf_hdr_id2name(const bcf_hdr_t *hdr, int rid) { return hdr->id[BCF_DT_CTG][rid].key; }

def _bcf_hdr_id2name(hdr: ptr[_bcf_hdr_t], rid: int):
    return hdr[0].id(int(BCF_DT_CTG))[rid]._key

def _bcf_hdr_id2type(hdr: ptr[_bcf_hdr_t], _type: i32, _int_id: i32):
    return (hdr[0]._id0[int(_int_id)]._val[0].info(int(_type)) >> u32(4)) & u32(0xf)

def _bcf_hdr_id2length(hdr: ptr[_bcf_hdr_t], _type: i32, _int_id: i32):
    return (hdr[0]._id0[int(_int_id)]._val[0].info(int(_type)) >> u32(8)) & u32(0xf)

def _bcf_hdr_id2number(hdr: ptr[_bcf_hdr_t], _type: i32, _int_id: i32):
    return hdr[0]._id0[int(_int_id)]._val[0].info(int(_type)) >> u32(12)

def _bcf_hdr_id2coltype(hdr: ptr[_bcf_hdr_t], _type: i32, _int_id: i32):
    return hdr[0]._id0[int(_int_id)]._val[0].info(int(_type)) & u32(0xf)

# ((int_id<0 || bcf_hdr_id2coltype(hdr,type,int_id)==0xf) ? 0 : 1)
def _bcf_hdr_idinfo_exists(hdr: ptr[_bcf_hdr_t], _type: i32, _int_id: i32):
    v = _int_id < i32(0) or (_bcf_hdr_id2coltype(hdr, _type, _int_id) == u32(0xf))
    return 0 if v else 1

def check_header_id(hdr: ptr[_bcf_hdr_t], h1_type: i32, id: i32):
    n = hdr[0]._n0
    return id >= i32(0) and id < n and _bcf_hdr_idinfo_exists(hdr, h1_type, id)

def is_gt_fmt(hdr: ptr[_bcf_hdr_t], fmt_id: i32):
    print("before str.from_ptr")
    fmt = str.from_ptr(_bcf_hdr_int2id(hdr, BCF_DT_ID, fmt_id))
    print("after fmt")
    return fmt == "GT"


def bcf_float_is_missing(f: i32):
    return 1 if f == i32(bcf_float_missing) else 0

def bcf_float_is_vector_end(f: i32):
    return 1 if f == i32(bcf_float_vector_end) else 0

#define bcf_gt_allele(val)      (((val)>>1)-1)
def bcf_gt_allele(val: int):
    return int((u64(val) >> u64(1)) - u64(1))

class BCFHeaderMetaData:
    bcf_hdr: ptr[_bcf_hdr_t]
    _type_code: int

    def __init__(self: BCFHeaderMetaData, bcf_hdr: ptr[_bcf_hdr_t], _type_code: int):
        self.bcf_hdr = bcf_hdr
        self._type_code = _type_code

    @property
    def type_code(self: BCFHeaderMetaData):
        return self._type_code
    
    def __len__(self: BCFHeaderMetaData):
        n = 0
        for i in range(self.bcf_hdr[0].n(int(BCF_DT_ID))):
            idpair = self.bcf_hdr[0].id(int(BCF_DT_ID)) + i
            if idpair[0]._key and idpair[0]._val and idpair._val[0].info(int(self._type_code)) & 0xF != 0xF:
                n += 1
            return n

    def __iter__(self: BCFHeaderMetaData):
        for i in range(int(self.bcf_hdr[0].n(int(BCF_DT_ID)))):
            idpair = self.bcf_hdr[0].id(int(BCF_DT_ID)) + i
            idinfo: _bcf_idinfo_t = idpair[0]._val[0]

            if idpair[0]._key and idpair[0]._val and idinfo.info(int(self._type_code)) & u32(0xF) != u32(0xF):
                yield str.from_ptr(idpair[0]._key)

class BCFHeaderContigs:
    bcf_hdr: ptr[_bcf_hdr_t]

    def __init__(self: BCFHeaderContigs, bcf_hdr: ptr[_bcf_hdr_t]):
        self.bcf_hdr = bcf_hdr
    
    def __iter__(self: BCFHeaderContigs):
        for i in range(int(self.bcf_hdr[0].n(int(BCF_DT_CTG)))):
            yield str.from_ptr(_bcf_hdr_id2name(self.bcf_hdr, i))

class BCFHeaderSamples:
    bcf_hdr: ptr[_bcf_hdr_t]

    def __init__(self: BCFHeaderSamples, bcf_hdr: ptr[_bcf_hdr_t]):
        self.bcf_hdr = bcf_hdr
    
    def __iter__(self: BCFHeaderSamples):
        for i in range(int(self.bcf_hdr[0].n(int(BCF_DT_SAMPLE)))):
            yield str.from_ptr(self.bcf_hdr[0]._samples[i])

METADATA_TYPES = ('FILTER', 'INFO', 'FORMAT', 'CONTIG', 'STRUCTURED', 'GENERIC')
class BCFHeaderRecord:
    bcf_hdr: ptr[_bcf_hdr_t]
    bcf_hrec: ptr[_bcf_hrec_t]

    def __init__(self: BCFHeaderRecord, bcf_hdr: ptr[_bcf_hdr_t], bcf_hrec: ptr[_bcf_hrec_t]):
        self.bcf_hdr = bcf_hdr
        self.bcf_hrec = bcf_hrec
    
    @property
    def hdr_type(self: BCFHeaderRecord):
        if not self.bcf_hrec:
            return 'None'
        return METADATA_TYPES[int(self.bcf_hrec[0]._type)]
    
    @property
    def key(self: BCFHeaderRecord):
        return str.from_ptr(self.bcf_hrec[0]._key) if self.bcf_hrec and self.bcf_hrec[0]._key else 'None'

    @property
    def value(self: BCFHeaderRecord):
        return str.from_ptr(self.bcf_hrec[0]._value) if self.bcf_hrec and self.bcf_hrec[0]._value else 'None'

    @property
    def attrs(self: BCFHeaderRecord):
        r = self.bcf_hrec[0]
        attrs = list[tuple[str, str]]((str.from_ptr(r._keys[i]) if r._keys[i] else 'None',
                            str.from_ptr(r._vals[i]) if r._vals[i] else 'None')
                            for i in range(int(self.bcf_hrec[0]._nkeys)))
        return attrs

    def __getitem__(self: BCFHeaderRecord, key: str):
        r = self.bcf_hrec
        if r:
            c_key = key.c_str()
            for i in range(int(r[0]._nkeys)):
                if r[0]._keys[i] and str.from_ptr(r[0]._keys[i]) == key:
                    return str.from_ptr(r[0]._vals[i]) if r[0]._vals[i] else 'None'
        raise KeyError('cant find key: ' + key)
    
    def __iter__(self: BCFHeaderRecord):
        r = self.bcf_hrec
        if r:
            for i in range(int(r[0]._nkeys)):
                if r[0]._keys[i]:
                    yield str.from_ptr(r[0]._keys[i])

    def __str__(self):
        pass

class BCFHeader:
    bcf_hdr: ptr[_bcf_hdr_t]
    def __init__(self: BCFHeader, bcf_hdr: ptr[_bcf_hdr_t]):
        self.bcf_hdr = bcf_hdr
    
    @property
    def info(self: BCFHeader):
        # get metadata for info fields in Header
        return BCFHeaderMetaData(self.bcf_hdr, int(BCF_HL_INFO))
    
    @property
    def filters(self: BCFHeader):
        return BCFHeaderMetaData(self.bcf_hdr, int(BCF_HL_FLT))

    @property
    def formats(self: BCFHeader):
        return BCFHeaderMetaData(self.bcf_hdr, int(BCF_HL_FMT))
    
    @property
    def contigs(self: BCFHeader):
        return BCFHeaderContigs(self.bcf_hdr)
    
    @property
    def samples(self: BCFHeader):
        return BCFHeaderSamples(self.bcf_hdr)

    def __iter__(self: BCFHeader):
        for i in range(int(self.bcf_hdr[0]._nhrec)):
            yield BCFHeaderRecord(self.bcf_hdr, self.bcf_hdr[0]._hrec[i])

# type_flag is one of BCF_BT_X, or BCF_HT_FLAG or BCF_AUX_NONE
# if array_flag is True, then BCFAux represents an array of type
# specified by type code
type BCFAux(_p: cobj, _type_code: i32, _is_array: bool):

    # accepts as T: i8, i16, i32
    @property
    def val[T](self: BCFAux):
        if self._is_array:
            raise TypeError("This BCFAux represents an array, not a single value")
        return ptr[T](self._p)[0]
    
    @property
    def arr[T](self: BCFAux):
        if not self._is_array:
            raise TypeError("This BCFAux represents a single value, not an array")
        return ptr[list[T]](self._p)[0]
    
    @property
    def type_code(self: BCFAux):
        return self._type_code
    
    @property
    def is_array(self: BCFAux):
        return self._is_array

def bcf_get_value_count(bcf1: ptr[_bcf1_t], bcf_hdr: ptr[_bcf_hdr_t], h1_type: i32, id: i32, sample: i32) -> tuple[i64, i32]:
    if not check_header_id(bcf_hdr, h1_type, id):
        raise ValueError("Invalid header")
    
    length = _bcf_hdr_id2length(bcf_hdr, h1_type, id)
    number = _bcf_hdr_id2number(bcf_hdr, h1_type, id)

    scalar = i32(0)
    count = i64(0)

    if h1_type == BCF_HL_FMT and is_gt_fmt(bcf_hdr, id):
        count = i64(int(number))
    elif i32(length) == BCF_VL_FIXED:
        scalar = i32(1)
    elif i32(length) == BCF_VL_R:
        count = i64(int(bcf1[0].n_allele))
    elif i32(length) == BCF_VL_A:
        count = i64(int(bcf1[0].n_allele - u32(1)))
    # TODO do
    # elif length == BCF_VL_G:
    #     count[0]
    elif i32(length) == BCF_VL_VAR:
        count = i64(-1)
    else:
        raise ValueError('Unknown format length')
    
    return (count, scalar)

def bcf_array_to_object(data: cobj, type_code: i32, n: i32, count: i64, scalar: i32) -> BCFAux:
    def bcf_num_array_to_object[T](data: cobj, type_code: i32, n: i32, vector_end: T, missing_val: T):
        arr = list[T]()
        nums = ptr[T](data)
        for i in range(int(n)):
            if nums[i] == vector_end:
                break
            if nums[i] != missing_val:
                arr.append(nums[i])
        return BCFAux(cobj(__ptr__(arr)), type_code, True)

    
    none_ret = BCFAux(cobj(data), BCF_AUX_NONE, False)
    if not data or n <= i32(0):
        return none_ret
    
    if type_code == BCF_BT_CHAR:
        datac = char_p(data)
        # check null terminator
        b: str = ""
        if datac[int(n)-1] == byte(bcf_str_vector_end):
            b = str.from_ptr(datac)
        else:
            copied_datac = char_p(int(n) + 1)
            for i in range(int(n)):
                copied_datac[i] = datac[i]
            copied_datac[int(n)] = byte(0)
            b = str.from_ptr(copied_datac)
        arr = list[str]()
        for c in b.split(','):
            if c.c_str()[0] != byte(bcf_str_missing):
                arr.append(c)
        return BCFAux(cobj(__ptr__(arr)), BCF_BT_CHAR, True)
    
    else:
        if type_code == BCF_BT_INT8:
            return bcf_num_array_to_object[i8](data, BCF_BT_INT8, n, i8(bcf_int8_vector_end), i8(bcf_int8_missing))
        elif type_code == BCF_BT_INT16:
            return bcf_num_array_to_object[i16](data, BCF_BT_INT16, n, i16(bcf_int16_vector_end), i16(bcf_int16_missing))
        elif type_code == BCF_BT_INT32:
            return bcf_num_array_to_object[i32](data, BCF_BT_INT32, n, i32(bcf_int32_vector_end), i32(bcf_int32_missing))
        elif type_code == BCF_BT_FLOAT:
            arr = list[i32]()
            nums = ptr[i32](data)
            for i in range(int(n)):
                if bcf_float_is_vector_end(i32(nums[i])):
                    break
                if not bcf_float_is_missing(i32(nums[i])):
                    arr.append(nums[i])
            return BCFAux(cobj(__ptr__(arr)), BCF_BT_FLOAT, True)
        else:
            raise TypeError('unsupported info type code')
    
    return none_ret    

def bcf_info_get_value(bcf1: ptr[_bcf1_t], bcf_hdr: ptr[_bcf_hdr_t], info: ptr[_bcf_info_t]) -> BCFAux:
    count_and_scalar = bcf_get_value_count(bcf1, bcf_hdr, BCF_HL_INFO, info[0]._key, i32(-1))
    count = count_and_scalar[0]
    scalar = count_and_scalar[1]

    i = info[0]
    t = i._type

    none_ret = BCFAux(cobj(bcf1), BCF_AUX_NONE, False)

    if i._len == i32(0):
        if _bcf_hdr_id2type(bcf_hdr, BCF_HL_INFO, i._key) == u32(BCF_HT_FLAG):
            value_p = ptr[bool](1)
            value_p[0] = True
            # TODO BCF_HT_FLAG is the same as BCF_BT_NULL, this may lead to some confusion
            return BCFAux(cobj(value_p), BCF_HT_FLAG, False)
        elif scalar != i32(0):
            # no value
            return none_ret
        else:
            # no value
            return none_ret
    elif i._len == i32(1):
        value = i32(i.v1)
        if i._type == BCF_BT_INT8:
            return BCFAux(cobj(__ptr__(value)), BCF_BT_INT8, False) if i._v1 != i32(bcf_int8_missing) else none_ret
        elif i._type == BCF_BT_INT16:
            return BCFAux(cobj(__ptr__(value)), BCF_BT_INT16, False) if i._v1 != i32(bcf_int16_missing) else none_ret 
        elif i._type == BCF_BT_INT32:
            return BCFAux(cobj(__ptr__(value)), BCF_BT_INT32, False) if i._v1 != i32(bcf_int32_missing) else none_ret
        elif i._type == BCF_BT_FLOAT:
            return BCFAux(cobj(__ptr__(value)), BCF_BT_FLOAT, False) if not bcf_float_is_missing(i._v1) else none_ret
        elif i._type == BCF_BT_CHAR:
            return BCFAux(cobj(__ptr__(value)), BCF_BT_CHAR, False)
        else:
            raise TypeError('unsupported info type code')
    else:
        return bcf_array_to_object(cobj(i._vptr), i._type, i._len, count, scalar)

class BCFRecordInfo:
    # mapping from info keys: values
    bcf1: ptr[_bcf1_t]
    bcf_hdr: ptr[_bcf_hdr_t]
    def __init__(self: BCFRecordInfo, bcf1: ptr[_bcf1_t], bcf_hdr: ptr[_bcf_hdr_t]):
        self.bcf1 = bcf1
        self.bcf_hdr = bcf_hdr
    
    def __iter__(self: BCFRecordInfo):
        hdr = self.bcf_hdr
        r = self.bcf1

        if bcf_unpack(cobj(r), BCF_UN_INFO) < 0:
            raise ValueError('Error unpacking info in BCFRecord')
                
        for i in range(int(r[0].n_info)):
            info = r[0]._d._info[i]
            if info._vptr:
                key = _bcf_hdr_int2id(hdr, BCF_DT_ID, info._key)
                key_s = str.from_ptr(key)
                if key_s != 'END':
                    yield key_s
    
    def __len__(self: BCFRecordInfo):
        count = 0
        for s in self:
            count += 1
        return count

    def __getitem__(self: BCFRecordInfo, key: str):
        hdr = self.bcf_hdr
        r = self.bcf1

        if bcf_unpack(cobj(r), BCF_UN_INFO) < 0:
            raise ValueError('Error unpacking info in BCFRecord')
        if key == "END":
            raise KeyError('END is a reserved key')

        c_key = key.c_str()
        info = ptr[_bcf_info_t](bcf_get_info(cobj(hdr), cobj(r), c_key))

        # TODO need to check for null info and implement bcf_header_get_info
        # see https://github.com/pysam-developers/pysam/blob/master/pysam/libcbcf.pyx#L545
        info_id = info[0]._key
        
        if info_id < i32(0):
            raise KeyError("Unknown info field: " + key)

        if not check_header_id(hdr, BCF_HL_INFO, info_id):
            raise ValueError("Invalid Header")

        # if flag then return whether points are not null
        if _bcf_hdr_id2type(hdr, BCF_HL_INFO, info_id) == u32(BCF_HT_FLAG):
            value_p = ptr[bool](1)
            value_p[0] = info and info[0]._vptr
            return BCFAux(cobj(value_p), BCF_HT_FLAG, False)
        
        if not info or not info[0]._vptr:
            raise KeyError('Invalid Info field: ' + key)

        return bcf_info_get_value(r, hdr, info)
    
class BCFRecordSample:
    bcf1: ptr[_bcf1_t]
    bcf_hdr: ptr[_bcf_hdr_t]
    index: int

    def __init__(self: BCFRecordSample, bcf1: ptr[_bcf1_t], bcf_hdr: ptr[_bcf_hdr_t], index: i32):
        self.index = index
        self.bcf1 = bcf1
        self.bcf_hdr = bcf_hdr 

    @property
    def name(self: BCFRecordSample):
        return str.from_ptr(self.bcf_hdr[0]._samples[self.index])

    # TODO, various operations like getting alleles, allele indices
    @property
    def alleles(self: BCFRecordSample) -> list[str]:
        r = self.bcf1[0]
        bcf_hdr = self.bcf_hdr
        index = self.index

        nsamples = r.n_sample
        nalleles = int(r.n_allele)
        alleles = list[str]()

        if bcf_unpack(cobj(self.bcf1), BCF_UN_ALL) < 0:
            raise ValueError("Error unpacking format")
        
        if index < 0 or index >= nsamples or not r.n_fmt:
            # TODO
            return alleles

        fmt0 = r._d._fmt[0]
        gt0 = is_gt_fmt(bcf_hdr, fmt0._id)

        if not gt0 or not fmt0._n:
            return alleles
        
        print("fmt0 type", fmt0._type)

        if fmt0._type == BCF_BT_INT8:
            data8 = ptr[i8](fmt0._p + index * int(fmt0._size))
            for i in range(int(fmt0._n)):
                if int(data8[i]) == bcf_int8_vector_end:
                    break
                a = bcf_gt_allele(int(data8[i]))
                alleles.append(str.from_ptr(r._d._allele[a]) if 0 <= a and a < nalleles else 'None')
        if fmt0._type == BCF_BT_INT16:
            data16 = ptr[i16](fmt0._p + index * int(fmt0._size))
            for i in range(int(fmt0._n)):
                if int(data16[i]) == bcf_int16_vector_end:
                    break
                a = bcf_gt_allele(int(data16[i]))
                alleles.append(str.from_ptr(r._d._allele[a]) if 0 <= a and a < nalleles else 'None')
        if fmt0._type == BCF_BT_INT32:
            data32 = ptr[i32](fmt0._p + index * int(fmt0._size))
            for i in range(int(fmt0._n)):
                if int(data32[i]) == bcf_int32_vector_end:
                    break
                a = bcf_gt_allele(int(data32[i]))
                alleles.append(str.from_ptr(r._d._allele[a]) if 0 <= a and a < nalleles else 'None')
        return alleles
    
    def __str__(self: BCFRecordSample):
        return self.name

class BCFRecordSamples:
    bcf1: ptr[_bcf1_t]
    bcf_hdr: ptr[_bcf_hdr_t]
    def __init__(self: BCFRecordSamples, bcf1: ptr[_bcf1_t], bcf_hdr: ptr[_bcf_hdr_t]):
        self.bcf1 = bcf1
        self.bcf_hdr = bcf_hdr
    
    def __len__(self: BCFRecordSamples):
        return self.bcf1[0].n_sample
    
    def __iter__(self: BCFRecordSamples):
        if bcf_unpack(cobj(self.bcf1), BCF_UN_ALL) < 0:
            raise ValueError("Error unpacking format")

        for i in range(int(len(self))):
            yield BCFRecordSample(self.bcf1, self.bcf_hdr, i)

class BCFRecordFormat:
    bcf1: ptr[_bcf1_t]
    bcf_hdr: ptr[_bcf_hdr_t]
    def __init__(self: BCFRecordFormat, bcf1: ptr[_bcf1_t], bcf_hdr: ptr[_bcf_hdr_t]):
        self.bcf1 = bcf1
        self.bcf_hdr = bcf_hdr
    
    def __len__(self: BCFRecordFormat):
        return self.bcf1[0].n_fmt
    
    def __iter__(self: BCFRecordFormat):
        if bcf_unpack(cobj(self.bcf1), BCF_UN_FMT) < 0:
            raise ValueError("Error unpacking format")

        for i in range(len(self)):
            fmt = self.bcf1[0]._d._fmt[i]
            if fmt._p:
                yield str.from_ptr(_bcf_hdr_int2id(self.bcf_hdr, BCF_DT_ID, fmt._id))

class BCFRecordFilter:
    bcf1: ptr[_bcf1_t]
    bcf_hdr: ptr[_bcf_hdr_t]

    def __init__(self: BCFRecordFilter, bcf1: ptr[_bcf1_t], bcf_hdr: ptr[_bcf_hdr_t]):
        self.bcf1 = bcf1
        self.bcf_hdr = bcf_hdr
    
    def __iter__(self: BCFRecordFilter):
        for i in range(int(self.bcf1[0]._d._n_flt)):
            yield str.from_ptr(_bcf_hdr_int2id(self.bcf_hdr, BCF_DT_ID, self.bcf1[0]._d._flt[i]))

    def __len__(self: BCFRecordFilter):
        return self.bcf1[0]._d._n_flt

class BCFRecord:
    bcf1: ptr[_bcf1_t]
    bcf_hdr: ptr[_bcf_hdr_t]
    _info: BCFRecordInfo
    _samples: BCFRecordSamples
    _formats: BCFRecordFormat
    _filters: BCFRecordFilter

    def __init__(self: BCFRecord, bcf1: ptr[_bcf1_t], bcf_hdr: ptr[_bcf_hdr_t]):
        self.bcf1 = bcf1
        self.bcf_hdr = bcf_hdr
        self._info = BCFRecordInfo(bcf1, bcf_hdr)
        self._samples = BCFRecordSamples(bcf1, bcf_hdr)
        self._formats = BCFRecordFormat(bcf1, bcf_hdr)
        self._filters = BCFRecordFilter(bcf1, bcf_hdr)
    
    @property
    def info(self: BCFRecord):
        return self._info
    
    @property
    def samples(self: BCFRecord):
        return self._samples

    @property
    def formats(self: BCFRecord):
        return self._formats
    
    @property
    def filters(self: BCFRecord):
        return self._filters

    @property
    def n_info(self: BCFRecord):
        return self.bcf1[0].n_info
    
    @property
    def chrom(self: BCFRecord):
        return str.from_ptr(_bcf_hdr_id2name(self.bcf_hdr, int(self.bcf1[0]._rid)))

    @property
    def contig(self: BCFRecord):
        return self.chrom

    @property
    def pos(self: BCFRecord):
        return self.bcf1[0]._pos
    
    @property
    def qual(self: BCFRecord):
        return self.bcf1[0]._qual
    
    @property
    def ref(self: BCFRecord):
        allele = self.bcf1[0]._d._allele
        return str.from_ptr(allele[0]) if allele else 'None'

    @property
    def id(self: BCFRecord):
        _id = self.bcf1[0]._d._id
        # ascii code for '.' is 46
        return str.from_ptr(_id) if _id[0] != byte(46) else 'None'
    
    @property
    def rlen(self: BCFRecord):
        return self.bcf1[0]._rlen

    def __str__(self: BCFRecord):
        return "[BCFRecord: id: " + self.id + ", chrom: " + self.chrom + ", pos: " + str(self.pos) + ", rlen: " + str(self.rlen) + ", n_info: " + str(self.n_info) + ", qual: " + str(self.qual) + ", ref: " + str(self.ref) + " ]"

class BCF:
    file: cobj
    bcf_hdr: cobj
    hdr: BCFHeader
    bcf1_recs: list[cobj]

    def __init__(self: BCF, path: str):
        path_c_str = path.c_str()
        file = hts_open(path_c_str, "rb".c_str())
        if not file:
            raise IOError("file " + path + " could not be opened")

        self.file = file
        self.bcf_hdr = bcf_hdr_read(self.file)
        self.hdr = BCFHeader(ptr[_bcf_hdr_t](self.bcf_hdr))
        self.bcf1_recs = list[cobj]()

    def _ensure_open(self: BCF):
        if not self.file:
            raise IOError("I/O operation on closed VCF/BCF file")

    def __iter__(self: BCF):
        self._ensure_open()
        while True:
            bcf1_rec = bcf_init()
            status = int(bcf_read(self.file, self.bcf_hdr, bcf1_rec))
            if status == 0:
                unpack_status = int(bcf_unpack(bcf1_rec, BCF_UN_FLT)) # TODO maybe change waht to unpack
                self.bcf1_recs.append(bcf1_rec)
                yield BCFRecord(ptr[_bcf1_t](bcf1_rec), ptr[_bcf_hdr_t](self.bcf_hdr))
            
            elif status == -1:
                # end of file
                bcf_destroy(bcf1_rec)
                break
            elif status < -1:
                raise IOError("Critical error while reading BCF file")
            else:
                break

    def close(self: BCF):
        for bcf1_rec in self.bcf1_recs:
            bcf_destroy(bcf1_rec)
        bcf_hdr_destroy(self.bcf_hdr)

parser = BCF('./valid_vcf.vcf')
for rec in parser:
    print(rec)
    for k in rec.info:
        aux = rec.info[k]
        type_code = aux.type_code
        is_array = aux._is_array
        if type_code == BCF_BT_INT8 :
            if is_array:
                print("key", k, "val", aux.arr[i8], "type_code", type_code)
            else:
                print("key", k, "val", aux.val[i8], "type_code", type_code)
        elif type_code == BCF_BT_INT16:
            if is_array:
                print("key", k, "val", aux.arr[i16], "type_code", type_code)
            else:
                print("key", k, "val", aux.val[i16], "type_code", type_code)
        elif type_code == BCF_BT_INT32:
            if is_array:
                print("key", k, "val", aux.arr[i32], "type_code", type_code)
            else:
                print("key", k, "val", aux.val[i32], "type_code", type_code)
        elif type_code == BCF_BT_FLOAT:
            if is_array:
                print("key", k, "val", aux.arr[i32], "type_code", type_code)
            else:
                print("key", k, "val", aux.val[i32], "type_code", type_code)
        elif type_code == BCF_BT_CHAR :
            if is_array:
                print("key", k, "val", aux.arr[str], "type_code", type_code)
            else:
                print("key", k, "val", aux.val[byte], "type_code", type_code)
        elif type_code == BCF_HT_FLAG :
            if is_array:
                print("key", k, "val", aux.arr[bool], "type_code", type_code)
            else:
                print("key", k, "val", aux.val[bool], "type_code", type_code)
    for samp in rec.samples:
        print("sample", samp)
        for allele in samp.alleles:
            print("allele", allele)
    for fm in rec.formats:
        print("format", fm)
    for fl in rec.filters:
        print("filter", fl)

print("Header data")
print("Header info")
hdr = parser.hdr
for k in hdr.info:
    print(k)
print("Header filters")
for k in hdr.filters:
    print(k)
print("Header formats")
for k in hdr.formats:
    print(k)
print("Header contigs")
for k in hdr.contigs:
    print(k)
print("Header samples")
for k in hdr.samples:
    print(k)
print("Header Records")
for r in hdr:
    print("Record: type:", r.hdr_type, "key", r.key, "value", r.value, "attrs", r.attrs)
    print("looping over hdr record")
    for _r in r:
        print("_r", _r, r[_r])
parser.close()



            




