from bio.fai import FAIRecord, FAI

# FASTA format parser
# https://en.wikipedia.org/wiki/FASTA_format
type FASTARecord(_header: str, _seq: seq):
    @property
    def header(self: FASTARecord):
        return self._header

    @property
    def name(self: FASTARecord):
        from bio.builtin import _split_header_on_space
        return _split_header_on_space(self.header)[0]

    @property
    def comment(self: FASTARecord):
        from bio.builtin import _split_header_on_space
        return _split_header_on_space(self.header)[1]

    @property
    def seq(self: FASTARecord):
        return self._seq

class FASTAReader:
    _file: cobj 
    path: str
    fai: list[FAIRecord]
    name_fai_map: dict[str, FAIRecord]
    validate: bool
    gzip: bool
    copy: bool

    def __init__(self: FASTAReader, path: str, validate: bool, gzip: bool, copy: bool, fai: bool):
        fai_list = list[FAIRecord]() if fai else None
        name_fai_map = dict[str, FAIRecord]() if fai else None

        if fai:
            for rec in FAI(path + ".fai", False):
                fai_list.append(rec)
                name_fai_map[rec.name] = rec

        self._file = gzopen(path, "r").__raw__() if gzip else open(path, "r").__raw__()
        self.path = path
        self.fai = fai_list
        self.name_fai_map = name_fai_map
        self.validate = validate
        self.gzip = gzip
        self.copy = copy

    @property
    def file(self: FASTAReader):
        assert not self.gzip
        p = __array__[cobj](1)
        p.ptr[0] = self._file
        return ptr[File](p.ptr)[0]

    @property
    def gzfile(self: FASTAReader):
        assert self.gzip
        p = __array__[cobj](1)
        p.ptr[0] = self._file
        return ptr[gzFile](p.ptr)[0]

    def __seqs__(self: FASTAReader):
        for rec in self:
            yield rec.seq

    def _check(b: byte, i: int):
        from bio.builtin import _is_iupac_nt
        if not _is_iupac_nt(b):
            raise ValueError(f"invalid base {repr(b)} at position {i} of sequence")

    def _append(p: ptr[byte], n: int, m: int, s: str, validate: bool):
        if n + s.len > m:
            m <<= 1
            if n + s.len > m:
                m = n + s.len
            p = _gc.realloc(p, m)
        if validate:
            i = 0
            while i < s.len:
                b = s.ptr[i]
                FASTAReader._check(b, i + n)
                p[i + n] = b
                i += 1
        else:
            str.memcpy(p + n, s.ptr, s.len)
        n += s.len
        return p, n, m

    def header_check(self: FASTAReader, rec_name: str, fai_name: str):
        if rec_name != fai_name:
            raise ValueError(f"FASTA index name mismatch: got {repr(rec_name)} but expected {repr(fai_name)}")
    
    def make_FASTARecord(self: FASTAReader, p: ptr[byte], expected_len: int, actual_len: int, fai_name: str, prev_header: str) -> FASTARecord:
        assert expected_len == actual_len
        rec = FASTARecord(prev_header, seq(p, expected_len))
        if self.validate:
            rec_name = rec.name
            self.header_check(rec_name, fai_name)
        return rec
    
    def extend_seq(self: FASTAReader, p: ptr[byte], expected_len: int, current_len: int, line: str):
        assert current_len + len(line) <= expected_len
        if self.validate:
            i = 0
            while i < len(line):
                b = line.ptr[i]
                FASTAReader._check(b, i + current_len)
                p[i + current_len] = b
                i += 1
        else:
            str.memcpy(p + current_len, line.ptr, len(line))

    def _iter_core(self: FASTAReader, file) -> FASTARecord:
        if self.fai is not None:
            idx = 0
            p = ptr[byte]()
            n = 0
            m = 0
            prev_header = ''
            for a in file._iter():
                if a == "": continue
                if a[0] == ">":
                    if n > 0:
                        yield self.make_FASTARecord(p, n, m, self.fai[idx - 1].name, prev_header)

                    prev_header = copy(a[1:])
                    n = self.fai[idx].length
                    p = ptr[byte](n)
                    m = 0
                    idx += 1
                else:
                    self.extend_seq(p, n, m, a)
                    m += len(a)

            if n > 0:
                yield self.make_FASTARecord(p, n, m, self.fai[idx - 1].name, prev_header)
        else:
            m = 256
            p = ptr[byte](m)
            n = 0
            curname = ""

            for a in file._iter():
                if a == "": continue
                if a[0] == ">":
                    if n > 0:
                        yield (curname, copy(seq(p, n)) if self.copy else seq(p, n))
                    curname = copy(a[1:])
                    n = 0
                else:
                    p, n, m = FASTAReader._append(p, n, m, a, self.validate)
            if n > 0:
                yield (curname, copy(seq(p, n)) if self.copy else seq(p, n))

    def __iter__(self: FASTAReader) -> FASTARecord:
        if self.gzip:
            yield from self._iter_core(self.gzfile)
        else:
            yield from self._iter_core(self.file)
        self.close()

    def __blocks__(self: FASTAReader, size: int):
        from bio.block import _blocks
        if not self.copy:
            raise ValueError("cannot read sequences in blocks with copy=False")
        return _blocks(self.__iter__(), size)

    def _getitem(self: FASTAReader, name: str, file):

        if not self.fai:
            raise ValueError("Need to set fai to True to reference by sequence name")
        if not name in self.name_fai_map:
            raise ValueError(f"Sequence with name {name} cannot be found")
        
        fai_rec = self.name_fai_map[name]
        
        old_file_pos = file.tell()
        file.seek(fai_rec.offset, 0)
        
        m = 0              # length of the sequence calculated from the line length
        n = fai_rec.length # length of the sequence, according to fai
        p = ptr[byte](n)
        s: seq = s''
        prev_header = fai_rec.name

        for a in file._iter():
            if a[0] == ">":
                if n > 0:
                    s = self.make_FASTARecord(p, n, m, fai_rec.name, prev_header).seq
                break
            else:
                self.extend_seq(p, n, m, a)
                m += len(a)

        if len(s) == 0 and n > 0:
            s = self.make_FASTARecord(p, n, m, fai_rec.name, prev_header).seq

        file.seek(old_file_pos, 0)

        return s
    
    # Uses already opened file if not yet closed
    # otherwise, reopens
    # Currently has 
    def __getitem__(self: FASTAReader, name: str):

        if self.gzip:
            if self.gzfile.closed():
                self._file = gzopen(self.path, "r").__raw__() if self.gzip else open(self.path, "r").__raw__()
            return self._getitem(name, self.gzfile)
        else:
            if self.file.closed():
                self._file = gzopen(self.path, "r").__raw__() if self.gzip else open(self.path, "r").__raw__()
            return self._getitem(name, self.file)

    def close(self: FASTAReader):
        if self.gzip:
            self.gzfile.close()
        else:
            self.file.close()

    def __enter__(self: FASTAReader):
        pass

    def __exit__(self: FASTAReader):
        self.close()

    def write(seqs_iter, path):
        LINE_LIMIT = 60
        with open(path, "w") as f:
            for i, s in enumerate(seqs_iter):
                f.write(">sequence")
                f.write(str(i))
                f.write("\n")
                n = 0
                while n < len(s):
                    end = min2(len(s), n + LINE_LIMIT)
                    f.write(str(s[n:end]))
                    f.write("\n")
                    n += LINE_LIMIT

def FASTA(path: str, validate: bool = True, gzip: bool = True, copy: bool = True, fai: bool = True):
    return FASTAReader(path=path, validate=validate, gzip=gzip, copy=copy, fai=fai)

from bio.pseq import pseq
type pFASTARecord(_name: str, _seq: pseq):
    @property
    def name(self: pFASTARecord):
        return self._name

    @property
    def seq(self: pFASTARecord):
        return self._seq

type pFASTAReader(_file: cobj, validate: bool, gzip: bool, copy: bool):
    def __init__(self: pFASTAReader, path: str, validate: bool, gzip: bool, copy: bool) -> pFASTAReader:
        return (gzopen(path, "r").__raw__() if gzip else open(path, "r").__raw__(), validate, gzip, copy)

    @property
    def file(self: pFASTAReader):
        assert not self.gzip
        p = __array__[cobj](1)
        p.ptr[0] = self._file
        return ptr[File](p.ptr)[0]

    @property
    def gzfile(self: pFASTAReader):
        assert self.gzip
        p = __array__[cobj](1)
        p.ptr[0] = self._file
        return ptr[gzFile](p.ptr)[0]

    def __seqs__(self: pFASTAReader):
        for rec in self:
            yield rec.seq

    def _check(b: byte, i: int):
        from bio.builtin import _is_iupac_aa
        if not _is_iupac_aa(b):
            raise ValueError(f"invalid amino acid {repr(b)} at position {i} of sequence")

    def _append(p: ptr[byte], n: int, m: int, s: str, validate: bool):
        if n + s.len > m:
            m <<= 1
            if n + s.len > m:
                m = n + s.len
            p = _gc.realloc(p, m)
        if validate:
            i = 0
            while i < s.len:
                b = s.ptr[i]
                pFASTAReader._check(b, i + n)
                p[i + n] = b
                i += 1
        else:
            str.memcpy(p + n, s.ptr, s.len)
        n += s.len
        return p, n, m

    def _iter_core(self: pFASTAReader, file) -> pFASTARecord:
        m = 256
        p = ptr[byte](m)
        n = 0
        curname = ""

        for a in file._iter():
            if a == "": continue
            if a[0] == ">":
                if n > 0:
                    yield (curname, copy(pseq(p, n)) if self.copy else pseq(p, n))
                curname = copy(a[1:])
                n = 0
            else:
                p, n, m = pFASTAReader._append(p, n, m, a, self.validate)
        if n > 0:
            yield (curname, copy(pseq(p, n)) if self.copy else pseq(p, n))

    def __iter__(self: pFASTAReader) -> pFASTARecord:
        if self.gzip:
            yield from self._iter_core(self.gzfile)
        else:
            yield from self._iter_core(self.file)
        self.close()

    def __blocks__(self: pFASTAReader, size: int):
        from bio.block import _blocks
        if not self.copy:
            raise ValueError("cannot read sequences in blocks with copy=False")
        return _blocks(self.__iter__(), size)

    def close(self: pFASTAReader):
        if self.gzip:
            self.gzfile.close()
        else:
            self.file.close()

    def __enter__(self: pFASTAReader):
        pass

    def __exit__(self: pFASTAReader):
        self.close()

def pFASTA(path: str, validate: bool = True, gzip: bool = True, copy: bool = True):
    return pFASTAReader(path=path, validate=validate, gzip=gzip, copy=copy)
