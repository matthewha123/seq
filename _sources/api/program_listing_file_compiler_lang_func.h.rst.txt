
.. _program_listing_file_compiler_lang_func.h:

Program Listing for File func.h
===============================

|exhale_lsh| :ref:`Return to documentation for file <file_compiler_lang_func.h>` (``compiler/lang/func.h``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. code-block:: cpp

   #pragma once
   
   #include "lang/stmt.h"
   #include "types/func.h"
   #include "types/generic.h"
   #include "types/types.h"
   #include "util/common.h"
   #include <unordered_map>
   
   namespace seq {
   class Expr;
   class Var;
   class Return;
   class Yield;
   
   class BaseFunc {
   protected:
     types::Type *parentType;
   
     llvm::Module *module;
   
     llvm::BasicBlock *preambleBlock;
   
     llvm::Function *func;
   
     BaseFunc();
   
   public:
     virtual bool isGen();
     virtual void resolveTypes();
     virtual void codegen(llvm::Module *module) = 0;
     llvm::LLVMContext &getContext();
     llvm::BasicBlock *getPreamble() const;
     virtual types::FuncType *getFuncType();
     virtual llvm::Function *getFunc(llvm::Module *module);
     virtual void setEnclosingClass(types::Type *parentType);
     virtual BaseFunc *clone(Generic *ref);
   };
   
   class Func : public BaseFunc, public Generic, public SrcObject {
   private:
     static std::unordered_map<std::string, Func *> builtins;
   
     bool external;
   
     std::string name;
   
     std::vector<types::Type *> inTypes;
   
     types::Type *outType;
   
     types::Type *outType0;
   
     std::vector<Expr *> defaultArgs;
   
     Block *scope;
   
     std::vector<std::string> argNames;
   
     std::map<std::string, Var *> argVars;
   
     std::vector<std::string> attributes;
   
     Func *parentFunc;
   
     Return *ret;
   
     Yield *yield;
   
     bool prefetch;
   
     bool interAlign;
   
     bool resolved;
   
     RCache<Func> cache;
   
     /*
      * Refer to https://llvm.org/docs/Coroutines.html for more
      * details on the following fields
      */
   
     bool gen;
   
     llvm::Value *promise;
   
     llvm::Value *handle;
   
     llvm::BasicBlock *cleanup;
   
     llvm::BasicBlock *suspend;
   
     llvm::BasicBlock *exit;
   
     std::string getMangledFuncName();
   
   public:
     Func();
     Block *getBlock();
   
     std::string genericName() override;
     void addCachedRealized(std::vector<types::Type *> types, Generic *x) override;
     Func *realize(std::vector<types::Type *> types);
     std::vector<types::Type *>
     deduceTypesFromArgTypes(std::vector<types::Type *> argTypes);
     std::vector<Expr *> rectifyCallArgs(std::vector<Expr *> args,
                                         std::vector<std::string> names,
                                         bool methodCall = false);
   
     void setEnclosingFunc(Func *parentFunc);
     void sawReturn(Return *ret);
     void sawYield(Yield *yield);
     void addAttribute(std::string attr);
     std::vector<std::string> getAttributes();
     bool hasAttribute(const std::string &attr);
   
     void resolveTypes() override;
     void codegen(llvm::Module *module) override;
     void codegenReturn(llvm::Value *val, types::Type *type,
                        llvm::BasicBlock *&block, bool dryrun = false);
     void codegenYield(llvm::Value *val, types::Type *type,
                       llvm::BasicBlock *&block, bool empty = false,
                       bool dryrun = false);
     llvm::Value *codegenYieldExpr(llvm::BasicBlock *&block, bool suspend = true);
   
     bool isGen() override;
     Var *getArgVar(std::string name);
     types::FuncType *getFuncType() override;
   
     void setExternal();
     void setIns(std::vector<types::Type *> inTypes);
     void setOut(types::Type *outType);
     void setDefaults(std::vector<Expr *> defaultArgs);
     void setName(std::string name);
     std::vector<std::string> getArgNames();
     void setArgNames(std::vector<std::string> argNames);
   
     Func *clone(Generic *ref) override;
   
     static Func *getBuiltin(const std::string &name);
   };
   
   class BaseFuncLite : public BaseFunc {
   private:
     std::vector<types::Type *> inTypes;
   
     types::Type *outType;
   
     std::function<llvm::Function *(llvm::Module *)> codegenLambda;
   
   public:
     BaseFuncLite(std::vector<types::Type *> inTypes, types::Type *outType,
                  std::function<llvm::Function *(llvm::Module *)> codegenLambda);
     void codegen(llvm::Module *module) override;
     types::FuncType *getFuncType() override;
     BaseFuncLite *clone(Generic *ref) override;
   };
   
   } // namespace seq
